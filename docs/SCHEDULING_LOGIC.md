# Scheduling Logic

## Overview

The scheduling system assigns courts, umpires, and timestamps to matches generated by the fixture system. It handles resource allocation, conflict prevention, and optimization for fair distribution of resources.

## Table of Contents

1. [Architecture](#architecture)
2. [Scheduling Flow](#scheduling-flow)
3. [Court Assignment](#court-assignment)
4. [Umpire Assignment](#umpire-assignment)
5. [Time Slot Calculation](#time-slot-calculation)
6. [Club Neutrality](#club-neutrality)
7. [Load Balancing](#load-balancing)
8. [Conflict Prevention](#conflict-prevention)

---

## Architecture

The scheduling logic is implemented in the `assignCourtsAndUmpires()` function in `src/services/fixtures.ts`. It takes:

- **Inputs:**
  - Match pairings (from fixture generation)
  - Available courts
  - Available umpires
  - Tournament entries and players
  - Start time
  - Slot duration
  - Batch size (max parallel matches)

- **Outputs:**
  - Scheduled matches with:
    - `court_id`
    - `umpire_id`
    - `scheduled_time`

---

## Scheduling Flow

```
For each round:
  1. Group matches by round
  2. Process matches in batches (parallel matches)
  3. For each batch:
      - Assign courts (round-robin rotation)
      - Assign umpires (with conflict checking)
      - Set scheduled time
  4. Move to next time slot
  5. Process next batch or next round
```

### Detailed Flow

```typescript
assignCourtsAndUmpires(matches, courts, umpires, entries, players, startTime, slotDuration, batchSize):

1. Initialize:
   - courtIndex = 0 (for rotation)
   - waveStart = startTime
   - umpireSchedule = Map<timeSlot, Set<umpireIds>>
   - umpireAssignmentCounts = Map<umpireId, count>

2. Group matches by round

3. For each round:
   a. For each batch (size = batchSize):
      - Calculate waveTime = waveStart + (waveIndex * slotDuration)
      - For each match in batch:
          * Assign court (round-robin from courts array)
          * Get available umpires at waveTime
          * Select best umpire (neutral + least assigned)
          * Assign umpire to time slot
          * Increment umpire assignment count
      - Increment waveIndex
   
   b. Calculate next round start time:
      - roundsInThisRound = ceil(matches.length / batchSize)
      - waveStart += roundsInThisRound * slotDuration

4. Return scheduled matches
```

---

## Court Assignment

### Algorithm: Round-Robin Rotation

Courts are assigned using a simple round-robin algorithm:

```typescript
court = courts[courtIndex % courts.length]
courtIndex++
```

### Properties

- **Fair Distribution:** Each court gets roughly equal number of matches
- **Simple:** No conflict checking needed (one match per court per time slot)
- **Predictable:** Easy to understand and debug

### Example

**3 Courts, 10 Matches:**
- Match 1: Court A
- Match 2: Court B
- Match 3: Court C
- Match 4: Court A (rotation starts over)
- Match 5: Court B
- ... and so on

### Constraints

- One match per court per time slot
- Court must be assigned to tournament
- If no courts available, `court_id = null`

---

## Umpire Assignment

Umpire assignment is more complex due to conflict prevention and optimization requirements.

### Algorithm: Conflict-Aware Selection

```
1. Track umpire assignments by time slot
2. For each match:
   a. Get available umpires (not assigned at this time)
   b. Filter for club neutrality (if enabled)
   c. Select umpire with least total assignments (load balancing)
   d. Assign to time slot
   e. Update assignment counts
```

### Time Slot Tracking

```typescript
// Map: timeSlotKey (ISO string) → Set of umpire IDs
umpireSchedule = new Map<string, Set<string>>()

// For each time slot:
const timeKey = getTimeSlotKey(waveTime)  // ISO string
const assignedUmpires = umpireSchedule.get(timeKey) || new Set()

// Available umpires = all umpires NOT in assignedUmpires
const availableUmpires = umpires.filter(
  u => !assignedUmpires.has(u.id)
)
```

### Conflict Prevention

**Rule:** One umpire cannot officiate multiple matches at the same time.

**Implementation:**
1. Store assigned umpire IDs per time slot
2. Before assigning, check if umpire is already assigned at that time
3. Only select from available umpires

**Example:**
```
Time: 09:00
  Match 1: Umpire A assigned
  Match 2: Umpire B assigned
  Match 3: Cannot use A or B → Use Umpire C

Time: 10:30
  Match 4: All umpires available (previous matches finished)
```

---

## Time Slot Calculation

### Slot Duration

```typescript
slotDurationMinutes = match_duration_minutes + rest_time_minutes
```

**Purpose:** Ensures sufficient time between matches on the same court.

### Batch Processing

Matches are processed in **batches** (parallel matches):

```typescript
batchSize = min(
  courts.length,
  umpires.length,
  max_parallel_matches_override || Infinity
)
```

**Example:**
- 3 courts, 5 umpires, no override → batchSize = 3
- Matches 1-3 start at 09:00
- Matches 4-6 start at 10:30 (after slot duration)
- Matches 7-9 start at 12:00

### Time Progression

**Within a Round:**
```
Round 1 (6 matches, batchSize=3):
  Wave 0 (09:00): Matches 1, 2, 3
  Wave 1 (10:30): Matches 4, 5, 6
  Wave 2: Not needed (all matches scheduled)
```

**Between Rounds:**
```
Round 1 ends: Last match at 12:00
Round 2 starts: 12:00 + slotDuration = 13:30
```

**Calculation:**
```typescript
// For next round:
roundsInThisRound = Math.ceil(roundMatches.length / batchSize)
waveStart.setMinutes(
  waveStart.getMinutes() + 
  roundsInThisRound * slotDurationMinutes
)
```

---

## Club Neutrality

Club neutrality ensures umpires are not from the same club as either participant in a match, preventing bias.

### Algorithm

```typescript
function selectBestUmpire(availableUmpires, match, entries, players, respectNeutrality):
  1. If respectNeutrality is false:
       return umpire with least assignments
   
  2. Extract club IDs from match participants:
     - Get entry1 → player1 → club_id
     - Get entry2 → player2 → club_id
   
  3. Filter neutral umpires:
     neutralUmpires = availableUmpires.filter(
       u => u.club_id !== player1Club && u.club_id !== player2Club
     )
   
  4. If neutral umpires exist:
       availableUmpires = neutralUmpires
   
  5. Select umpire with least total assignments
```

### Example

**Players:**
- Player A (Club X) vs Player B (Club Y)
- Available Umpires:
  - Umpire 1 (Club X) ❌ - Same club as Player A
  - Umpire 2 (Club Y) ❌ - Same club as Player B
  - Umpire 3 (Club Z) ✅ - Neutral
  - Umpire 4 (Club W) ✅ - Neutral

**Selection:** Umpire 3 or 4 (whichever has fewer assignments)

### Fallback

If no neutral umpires are available:
- Uses best available umpire (may be from same club)
- System generates a warning

---

## Load Balancing

Umpires are distributed evenly across all matches to prevent overwork.

### Algorithm

```typescript
// Track total assignments per umpire
umpireAssignmentCounts = Map<umpireId, count>

// Select umpire with minimum assignments
bestUmpire = availableUmpires.reduce((best, current) => {
  const bestCount = umpireAssignmentCounts.get(best.id) || 0
  const currentCount = umpireAssignmentCounts.get(current.id) || 0
  return currentCount < bestCount ? current : best
})
```

### Example

**5 Matches, 3 Umpires:**

| Match | Umpire Counts | Selected |
|-------|---------------|----------|
| 1 | A:0, B:0, C:0 | A (arbitrary, all equal) |
| 2 | A:1, B:0, C:0 | B (least) |
| 3 | A:1, B:1, C:0 | C (least) |
| 4 | A:1, B:1, C:1 | A (all equal, round-robin) |
| 5 | A:2, B:1, C:1 | B or C (least) |

**Result:** Even distribution (2-2-1 or 2-1-2)

### Benefits

- Prevents umpire fatigue
- Fair work distribution
- Better resource utilization

---

## Conflict Prevention

### Multiple Conflict Types

1. **Time Conflicts:** Same umpire at same time
2. **Club Conflicts:** Umpire from same club as participants
3. **Over-assignment:** Too many matches for one umpire

### Conflict Resolution

**Time Conflicts:**
- Prevented by time slot tracking
- Solution: Select different umpire for same time slot

**Club Conflicts:**
- Prevented by club neutrality filtering
- Solution: Prefer neutral umpires, fallback to available

**Over-assignment:**
- Prevented by load balancing
- Solution: Distribute assignments evenly

### Edge Cases

**Case 1: More Matches Than Umpires**
- Some umpires will be assigned to multiple matches
- Load balancing ensures fair distribution
- Example: 10 matches, 3 umpires → roughly 3-4 matches each

**Case 2: Same Time Slot, Fewer Umpires**
- If `batchSize > umpires.length`, some matches get `umpire_id = null`
- System handles gracefully (match can still proceed)

**Case 3: No Available Umpires**
- Match gets `umpire_id = null`
- Organizer can manually assign later

---

## Example Scenarios

### Scenario 1: Small Tournament

**Setup:**
- 4 participants (knockouts)
- 2 courts
- 2 umpires
- Match duration: 60 min
- Rest time: 15 min
- Slot duration: 75 min

**Schedule:**

| Match | Round | Time | Court | Umpire |
|-------|-------|------|-------|--------|
| 1 | Round 1 | 09:00 | A | Umpire 1 |
| 2 | Round 1 | 09:00 | B | Umpire 2 |
| 3 | Semifinals | 10:15 | A | Umpire 1 |
| 4 | Semifinals | 10:15 | B | Umpire 2 |
| 5 | Final | 11:30 | A | Umpire 1 |

### Scenario 2: Round Robin with Club Neutrality

**Setup:**
- 6 participants (round robin)
- 2 courts
- 3 umpires
- Participants from Club X, Y, Z

**Processing:**
- Match 1: Club X vs Club Y → Assign Umpire Z (neutral)
- Match 2: Club Y vs Club Z → Assign Umpire X (neutral)
- Match 3: Club X vs Club Z → Assign Umpire Y (neutral)

### Scenario 3: Large Tournament

**Setup:**
- 32 participants (knockouts)
- 4 courts
- 5 umpires
- Batch size: 4 (matches per time slot)

**Round 1 (16 matches):**
- Time 09:00: Matches 1-4 (4 matches)
- Time 10:30: Matches 5-8 (4 matches)
- Time 12:00: Matches 9-12 (4 matches)
- Time 13:30: Matches 13-16 (4 matches)

**Load Distribution:**
- Each umpire: ~3-4 matches in Round 1
- Evenly distributed across time slots

---

## Performance Considerations

1. **Efficient Data Structures**
   - Maps and Sets for O(1) lookup
   - Prevents O(n²) complexity

2. **Batch Processing**
   - Groups matches by time slots
   - Reduces scheduling iterations

3. **Early Filtering**
   - Filters available umpires first
   - Then applies neutrality and load balancing

---

## Configuration Options

### Scheduling Parameters

```typescript
{
  start_time_override?: string;          // Custom start time
  max_parallel_matches_override?: number;// Max concurrent matches
  respect_club_neutrality?: boolean;     // Enable club neutrality
}
```

### Tournament Settings

- `match_duration_minutes` - Duration of each match
- `rest_time_minutes` - Rest time between matches
- `start_date` - Tournament start date (defaults to 9:00 AM)

---



